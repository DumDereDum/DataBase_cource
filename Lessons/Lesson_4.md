# Типы данных

В PostgreSQL, как и во многих других реляционных базах данных, существует несколько типов данных. Некоторые из них включают:

1. Целочисленные типы данных:

    * INTEGER - целые числа.
    * BIGINT - целые числа большего размера.
    * SMALLINT - целые числа меньшего размера.
    * SERIAL - целочисленный тип данных, автоматически увеличивающийся при каждой вставке новой строки в таблицу.

2. Типы данных с плавающей запятой:

    * REAL - числа с плавающей точкой меньшей точности.
    * DOUBLE PRECISION - числа с плавающей точкой большей точности.

3. Типы данных для текста и символов:

    * CHAR(n) - фиксированная длина строки.
    * VARCHAR(n) - строка переменной длины.
    * TEXT - строка переменной длины (большой размер).
    * CHARACTER VARYING(n) - альтернативный синтаксис для строк переменной длины.

4. Типы данных для даты и времени:

    * DATE - только дата.
    * TIME - только время.
    * TIMESTAMP - дата и время.
    * INTERVAL - интервал времени.

5. Логический тип данных:

    * BOOLEAN - принимает значения TRUE или FALSE.

6. Бинарные типы данных:

    * BYTEA - для хранения бинарных данных.

7. Геометрические типы данных:

    * POINT: Один набор координат (x, y).
    * LINE: Отрезок или линия, состоящая из точек.
    * LSEG: Отрезок с начальной и конечной точками.
    * BOX: Прямоугольная область с двумя угловыми точками.
    * PATH: Замкнутая или открытая кривая, состоящая из линий и дуг.
    * POLYGON: Замкнутая фигура, состоящая из упорядоченных вершин.
    * CIRCLE: Окружность с центром и радиусом.

8. JSON и JSONB:

    * JSON - для хранения данных в формате JSON.
    * JSONB - для хранения JSON в бинарном формате.

9. ENUM:

    * ENUM - перечислимый тип данных.

Это основные типы данных в PostgreSQL, хотя существуют и другие расширения и пользовательские типы данных, которые могут быть определены в базе данных.


# Primary Key

Primary Key (первичный ключ) в реляционных базах данных, в том числе и в PostgreSQL, представляет собой уникальный идентификатор каждой записи в таблице. Каждая таблица должна иметь первичный ключ, который гарантирует уникальность идентификации записей.

Вот некоторые особенности первичного ключа в PostgreSQL:

1. **Уникальность:** Каждое значение первичного ключа в столбце таблицы должно быть уникальным для каждой строки в этой таблице.

2. **Не-null значения:** Значение первичного ключа не может быть NULL. Это гарантирует, что у каждой строки в таблице будет уникальный идентификатор.

3. **Автоматическое индексирование:** По умолчанию PostgreSQL автоматически создает индекс для первичного ключа, что ускоряет поиск и доступ к данным.

4. **Ограничение на один ключ на таблицу:** Каждая таблица может иметь только один первичный ключ. Однако составной первичный ключ может включать несколько столбцов.

Пример создания таблицы с первичным ключом в PostgreSQL:

```SQL
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL
);
```
В этом примере user_id является первичным ключом таблицы users. Тип данных SERIAL обозначает автоинкрементное целое число, которое PostgreSQL автоматически увеличивает при вставке новых записей. Ключевое слово PRIMARY KEY указывает, что столбец user_id является первичным ключом таблицы.

При проектировании базы данных важно выбирать подходящие поля для первичных ключей, чтобы обеспечить эффективность запросов и целостность данных.

# Индексы

В PostgreSQL индексы - это структуры данных, используемые для ускорения выполнения запросов к таблицам. Они позволяют быстро находить строки в таблице, соответствующие определенным условиям, и улучшают производительность запросов SELECT, UPDATE, DELETE.

Вот некоторые типы индексов и их краткое описание:

### B-Tree индексы:
* Алгоритм: B-Tree (сбалансированное дерево).
* Описание: B-Tree индексы используют сбалансированное дерево для хранения ключей индекса. Этот тип индекса эффективен для равенственных и диапазонных запросов, так как B-Tree позволяет быстро найти значения в порядке сортировки. Время доступа к данным в B-Tree индексе логарифмическое по высоте дерева
```SQL
CREATE INDEX idx_name ON table_name(column_name);
```

### Hash индексы: 
* Алгоритм: Хеш-функция.
* Описание: Hash индексы используют хеш-функции для быстрого поиска значений. Они хорошо работают для точного сравнения, поскольку хеш-функции позволяют быстро найти точное значение ключа. Однако они не подходят для диапазонных запросов, поскольку данные не упорядочены.
```SQL
CREATE INDEX idx_name ON table_name USING HASH (column_name);
```

### GiST (Generalized Search Tree) индексы: 
* Алгоритм: Обобщенное дерево поиска.
* Описание: GiST индексы позволяют индексировать данные, которые не могут быть эффективно обработаны стандартными B-Tree индексами. Они могут использоваться для геометрических объектов, текстовых данных и других типов данных, где необходимо определить пользовательские операции поиска и сравнения.
```SQL
CREATE INDEX idx_name ON table_name USING gist (column_name);
```

### GIN (Generalized Inverted Index) индексы: 
* Алгоритм: Обобщенный инвертированный индекс.
* Описание: GIN индексы используются для полнотекстового поиска и индексации массивов. Они обеспечивают эффективный способ индексации данных, которые не подходят для обычных B-Tree индексов, таких как полнотекстовый поиск, поиск по массивам и другие операции, требующие семантического поиска.
```SQL
CREATE INDEX idx_name ON table_name USING gin (column_name);
```

### Пример использования индекса для улучшения производительности запроса:

```SQL
CREATE INDEX idx_name ON table_name(column_name);
SELECT * FROM table_name WHERE column_name = 'value';
```

Индексы помогают ускорить запросы, но их следует использовать осторожно, поскольку они также влияют на производительность операций вставки (INSERT), обновления (UPDATE) и удаления (DELETE), так как при изменении данных индексы также должны быть обновлены. Важно также правильно выбирать столбцы для индексации, основываясь на типах запросов, которые часто выполняются в вашем приложении.

## Пример
```SQL
CREATE TABLE books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255),
    author VARCHAR(255),
    genre VARCHAR(100),
    publish_year INTEGER
);
-- DROP TABLE books

INSERT INTO books (title, author, genre, publish_year) VALUES
    ('To Kill a Mockingbird', 'Harper Lee', 'Fiction', 1960),
    ('1984', 'George Orwell', 'Dystopian', 1949),
    ('Pride and Prejudice', 'Jane Austen', 'Romance', 1813),
    ('The Great Gatsby', 'F. Scott Fitzgerald', 'Fiction', 1925),
    ('The Catcher in the Rye', 'J.D. Salinger', 'Fiction', 1951);

SELECT * FROM books;
```

```SQL
EXPLAIN ANALYZE SELECT * FROM books WHERE author = 'George Orwell';

-- "Planning Time: 0.043 ms"
-- "Execution Time: 0.020 ms"
```

```SQL
CREATE INDEX idx_author ON books(author);
EXPLAIN ANALYZE SELECT * FROM books WHERE author = 'George Orwell';

-- "Planning Time: 0.330 ms"
-- "Execution Time: 0.016 ms"
```

### EXPLAIN ANALYZE

EXPLAIN ANALYZE - это инструмент в PostgreSQL, который используется для анализа выполнения запросов и оценки их производительности. Он предоставляет подробную информацию о том, как PostgreSQL выполняет запросы, включая способы доступа к данным, используемые алгоритмы и время выполнения операций.

Основная цель EXPLAIN ANALYZE - помочь оптимизировать выполнение запросов и улучшить производительность базы данных. Вот как он работает:

1. **EXPLAIN**: Команда EXPLAIN анализирует план выполнения запроса, но не выполняет его на самом деле. Он выводит оптимизированный план запроса, который PostgreSQL собирается использовать для выполнения запроса.

2. **ANALYZE**: Команда ANALYZE фактически выполняет запрос и собирает статистику о том, сколько времени занимает выполнение каждой операции и сколько строк обрабатывается.

Когда комбинируются обе команды - EXPLAIN ANALYZE, PostgreSQL выполняет запрос, а затем анализирует его выполнение и выводит детальную информацию о том, как был выполнен запрос и сколько времени заняло каждое его компонент.

Пример использования EXPLAIN ANALYZE:

```SQL
EXPLAIN ANALYZE SELECT * FROM books WHERE author = 'George Orwell';
```
Результат выполнения команды EXPLAIN ANALYZE будет включать план выполнения запроса, оценку стоимости каждой операции, количество строк, обработанных каждой операцией, и общее время выполнения запроса. Эти данные могут помочь идентифицировать узкие места в запросах и улучшить их производительность.